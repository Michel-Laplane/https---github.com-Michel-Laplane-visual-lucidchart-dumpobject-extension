import { CollectionProxy } from '../../data/collectionproxy';
import { DataSourceProxy } from '../../data/datasourceproxy';
import { TextStyle } from '../../document/text/textstyle';
import { EditorClient } from '../../editorclient';
import { SerializedFieldType } from '../data/serializedfield/serializedfields';
import { CardIntegrationConfig } from './cardintegrationconfig';
import { ExtensionCardFieldDefinition } from './cardintegrationdefinitions';
import { LucidCardIntegrationCustomImportModal } from './lucidcardintegrationcustomimportmodal';
import { LucidCardIntegrationStandardImportModal } from './lucidcardintegrationstandardimportmodal';
export { ImportResult, SearchResult } from './lucidcardintegrationstandardimportmodal';
export declare abstract class LucidCardIntegration {
    protected readonly client: EditorClient;
    constructor(client: EditorClient);
    /**
     * Label used to identify the integration, e.g. "Jira", which will be used in menu items, etc.
     * Should be unique within any given extension.
     */
    abstract label: string;
    /**
     * Label used to identify one card worth of data, e.g. "Jira task"
     */
    abstract itemLabel: string;
    /**
     * Label used to identify multiple cards worth of data, e.g. "Jira tasks"
     */
    abstract itemsLabel: string;
    /**
     * URL for an icon to display in toolbars, etc. Should be at least 24x24.
     */
    abstract iconUrl: string;
    /**
     * The name of the data connector associated with the card integration.
     */
    abstract dataConnectorName: string;
    /**
     * The default text style to use on cards created as part of this integration.
     * These can be overridden by values in getDefaultConfig().fieldStyles for
     * individual fields that should have different styles.
     */
    textStyle?: Partial<TextStyle>;
    abstract fieldConfiguration: {
        /**
         * Callback to provide a list of all supported field names for the card integration.
         */
        getAllFields: (dataSource: DataSourceProxy) => Promise<string[]>;
        /**
         * Callback that handled changes in the fields the user wants to be displayed in the card integration.
         * If this callback is not provided then the user will not be shown the modal to configure fields.
         */
        onSelectedFieldsChange?: (dataSource: DataSourceProxy, selectedFields: string[]) => Promise<void>;
        /**
         * Specify callbacks for searching for legal values for the given fields.
         *
         * For example, a Task collection may have an Assignee field that references a User collection,
         * but you don't import all the users in the entire source data set. Here, you can provide a way
         * to search for legal values for the Assignee field, similar to the `ExtensionCardFieldDefinition.search`
         * functionality.
         *
         * Register a search callback using LucidCardIntegrationRegistry.registerFieldSearchCallback, then set
         * the returned string as a value in this Map. The `inputSoFar` parameter passed to the callback will
         * be all the current field values on the item being edited.
         */
        fieldValueSearchCallbacks?: Map<string, string>;
    };
    /**
     * If specified, and the user hasn't yet authorized the data connector for this extension,
     * this should show the user an intro dialog or take some other action.
     */
    showIntro?: () => void;
    /**
     * Provide the default configuration for a new import
     */
    abstract getDefaultConfig: (dataSource: DataSourceProxy) => Promise<CardIntegrationConfig>;
    /**
     * This allows the user to import cards by selecting items from within a modal. You can either create a custom
     * import modal or the standard import modal can be used.
     */
    importModal?: LucidCardIntegrationStandardImportModal | LucidCardIntegrationCustomImportModal;
    /**
     * If specified, allow the user to create new cards and convert other shapes to cards
     */
    addCard?: {
        /**
         * Given the values entered by the user so far into input fields, return the list of all input fields
         * to display in the create-card form.
         */
        getInputFields: (inputSoFar: Map<string, SerializedFieldType>) => Promise<ExtensionCardFieldDefinition[]>;
        /**
         * Given the values entered by the user into input fields, create a new data record to represent the
         * created card, and return information about that record.
         */
        createCardData: (input: Map<string, SerializedFieldType>) => Promise<{
            collection: CollectionProxy;
            primaryKey: string;
        }>;
    };
    showCardImport(name: string): import("../../commandtypes").ImportCardsResult;
}
