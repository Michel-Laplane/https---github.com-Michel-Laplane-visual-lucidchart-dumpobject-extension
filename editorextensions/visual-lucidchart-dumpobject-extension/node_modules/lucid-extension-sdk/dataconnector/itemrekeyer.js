"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemRekeyer = exports.RekeyingMap = void 0;
const fieldspecification_1 = require("../core/data/fieldspecification");
const object_1 = require("../core/object");
const patch_1 = require("./actions/patch");
const datasourceupdatetypes_1 = require("./datasourceupdatetypes");
function calculateRekeyingMap(itemsPatch, primaryKey) {
    var _a, _b;
    if (itemsPatch instanceof datasourceupdatetypes_1.ItemsPatchExhaustive) {
        return itemsPatch.rekeyingMap;
    }
    else {
        if (!primaryKey) {
            return undefined;
        }
        const constPrimaryKey = primaryKey;
        function primaryKeyIfChanged(oldPrimaryKey, item) {
            const changedParts = constPrimaryKey.elements.map((field) => item[field]);
            if (changedParts.find((x) => x !== undefined) === undefined) {
                // this patch didn't touch the primary key
                return undefined;
            }
            // we might need parts of the old primary key if only some of the primary key fields changed.
            // As an optimization we could only compute this if at least one of the changedParts is
            // undefined.
            const oldParts = JSON.parse(`[${oldPrimaryKey}]`);
            const newParts = changedParts.map((part, index) => (part !== undefined ? part : oldParts[index]));
            const newPrimaryKey = fieldspecification_1.FormattedPrimaryKey.serializeList(newParts);
            if (newPrimaryKey !== oldPrimaryKey) {
                return newPrimaryKey;
            }
            else {
                return undefined;
            }
        }
        const itemsMap = [...itemsPatch.items.entries()]
            .map(([key, value]) => [key, primaryKeyIfChanged(key, value)])
            .filter((x) => x[1] !== undefined);
        const deletedMap = (_b = (_a = itemsPatch.itemsDeleted) === null || _a === void 0 ? void 0 : _a.map((key) => [key, null])) !== null && _b !== void 0 ? _b : [];
        const theMap = new Map([...itemsMap, ...deletedMap]);
        return theMap.size > 0 ? theMap : undefined;
    }
}
class RekeyingMap {
    constructor(map) {
        this.map = map;
    }
    getNewKey(key) {
        var _a;
        return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : key;
    }
    getRecordWithNewKeys(items) {
        return (0, object_1.fromEntries)(Object.entries(items).map(([key, value]) => [this.getNewKey(key), value]));
    }
    getRekeyedPatch(patch) {
        var _a;
        if (patch instanceof patch_1.ItemPatch) {
            return new patch_1.ItemPatch(patch.id, this.getRecordWithNewKeys(patch.itemsAdded), this.getRecordWithNewKeys(patch.itemsChanged), patch.itemsDeleted.map((key) => this.getNewKey(key)), (_a = patch.itemOrderChanged) === null || _a === void 0 ? void 0 : _a.map(([a, b]) => [this.getNewKey(a), b && this.getNewKey(b)]), patch.syncSourceId, patch.syncCollectionId);
        }
        return patch.clone();
    }
}
exports.RekeyingMap = RekeyingMap;
class ItemRekeyer {
    constructor() {
        this.rekeyingMaps = new Map();
    }
    addRekeyingsFor(collectionId, itemsPatch, primaryKey) {
        var _a;
        const rekeyingMap = calculateRekeyingMap(itemsPatch, primaryKey);
        if (rekeyingMap) {
            const existingMap = this.rekeyingMaps.get(collectionId);
            const rekeyedExisting = [...((_a = existingMap === null || existingMap === void 0 ? void 0 : existingMap.map.entries()) !== null && _a !== void 0 ? _a : [])].map(([key, value]) => { var _a; return [key, value && ((_a = rekeyingMap.get(value)) !== null && _a !== void 0 ? _a : value)]; });
            this.rekeyingMaps.set(collectionId, new RekeyingMap(new Map([...rekeyingMap.entries(), ...rekeyedExisting])));
        }
    }
    getRekeyingMap(patch) {
        return this.rekeyingMaps.get(patch.syncCollectionId);
    }
}
exports.ItemRekeyer = ItemRekeyer;
