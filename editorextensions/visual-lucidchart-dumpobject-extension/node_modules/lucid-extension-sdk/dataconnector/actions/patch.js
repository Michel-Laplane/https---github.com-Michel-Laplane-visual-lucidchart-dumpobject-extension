"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schemaPatchParser = exports.SchemaPatch = exports.ThirdPartyColumnPatch = exports.ThirdPartyColumn = exports.itemPatchParser = exports.ItemPatch = exports.genericPatchParser = exports.Patch = void 0;
const fieldtypedefinition_1 = require("../../core/data/fieldtypedefinition/fieldtypedefinition");
const patchresponsebody_1 = require("./patchresponsebody");
const serializedpatchtypes_1 = require("./serializedpatchtypes");
function objMap(obj, f) {
    const result = {};
    for (const key in obj) {
        result[key] = f(obj[key]);
    }
    return result;
}
/** A patch to be applied against the 3rd party datasource with changes coming from Lucid */
class Patch {
    constructor(
    /** The id of the patch */
    id, 
    /** The syncSourceId of the changed data source */
    syncSourceId, 
    /** The syncCollectionId of the changed collection */
    syncCollectionId) {
        this.id = id;
        this.syncSourceId = syncSourceId;
        this.syncCollectionId = syncCollectionId;
    }
    getChange(collections = []) {
        return new patchresponsebody_1.PatchChange(this.id, this.syncSourceId, collections);
    }
}
exports.Patch = Patch;
const genericPatchParser = (id, x) => {
    var _a;
    return (_a = (0, exports.itemPatchParser)(id, x)) !== null && _a !== void 0 ? _a : (0, exports.schemaPatchParser)(id, x);
};
exports.genericPatchParser = genericPatchParser;
class ItemPatch extends Patch {
    constructor(
    /** The id of the patch */
    id, 
    /** Mapping of item primary keys to new items introduced by Lucid */
    itemsAdded, 
    /** Mapping of item primary keys to sparse changesets of pre-existing items changed by Lucid */
    itemsChanged, 
    /** List of item primary keys deleted by Lucid */
    itemsDeleted, 
    /** */
    itemOrderChanged, 
    /** The syncSourceId of the changed data source */
    syncSourceId, 
    /** The syncCollectionId of the changed collection */
    syncCollectionId) {
        super(id, syncSourceId, syncCollectionId);
        this.itemsAdded = itemsAdded;
        this.itemsChanged = itemsChanged;
        this.itemsDeleted = itemsDeleted;
        this.itemOrderChanged = itemOrderChanged;
    }
    toJSON() {
        return {
            'Id': this.id,
            'ItemsAdded': this.itemsAdded,
            'ItemsChanged': this.itemsChanged,
            'ItemsDeleted': this.itemsDeleted,
            'ItemOrderChanged': this.itemOrderChanged,
            'SyncSourceId': this.syncSourceId,
            'SyncCollectionId': this.syncCollectionId,
        };
    }
    clone() {
        return new ItemPatch(this.id, objMap(this.itemsAdded, (item) => objMap(item, (v) => v)), objMap(this.itemsChanged, (item) => objMap(item, (v) => v)), [...this.itemsDeleted], this.itemOrderChanged && [...this.itemOrderChanged], this.syncSourceId, this.syncCollectionId);
    }
}
exports.ItemPatch = ItemPatch;
function _itemPatchParser(id, patch) {
    var _a;
    return new ItemPatch(id, patch['itemsAdded'], patch['itemsChanged'], patch['itemsDeleted'], (_a = patch['itemOrderChanged']) !== null && _a !== void 0 ? _a : undefined, patch['syncSourceId'], patch['syncCollectionId']);
}
const itemPatchParser = (id, patch) => {
    if ((0, serializedpatchtypes_1.patchItemValidator)(patch)) {
        return _itemPatchParser(id, patch);
    }
    return undefined;
};
exports.itemPatchParser = itemPatchParser;
class ThirdPartyColumn {
    constructor(name, fieldType) {
        this.name = name;
        this.fieldType = fieldType;
    }
    clone() {
        return new ThirdPartyColumn(this.name, this.fieldType);
    }
    toJSON() {
        return { 'Name': this.name, 'FieldType': (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(this.fieldType) };
    }
    static deserialize(data) {
        return new ThirdPartyColumn(data['name'], (0, fieldtypedefinition_1.deserializeFieldTypeDefinition)(data['fieldType']));
    }
}
exports.ThirdPartyColumn = ThirdPartyColumn;
class ThirdPartyColumnPatch {
    constructor(name, fieldType) {
        this.name = name;
        this.fieldType = fieldType;
    }
    clone() {
        return new ThirdPartyColumnPatch(this.name, this.fieldType);
    }
    toJSON() {
        return {
            'Name': this.name,
            'FieldType': this.fieldType != null ? (0, fieldtypedefinition_1.serializeFieldTypeDefinition)(this.fieldType) : undefined,
        };
    }
    static deserialize(data) {
        var _a;
        const result = new ThirdPartyColumnPatch((_a = data['name']) !== null && _a !== void 0 ? _a : undefined, data['fieldType'] != null ? (0, fieldtypedefinition_1.deserializeFieldTypeDefinition)(data['fieldType']) : undefined);
        console.log(`\n\nSerialization result: ${JSON.stringify(result.toJSON())}\n\n`);
        return result;
    }
}
exports.ThirdPartyColumnPatch = ThirdPartyColumnPatch;
class SchemaPatch extends Patch {
    constructor(
    /** The id of the patch */
    id, 
    /** Mapping of item primary keys to new items introduced by Lucid */
    columnsAdded, 
    /** Mapping of item primary keys to sparse changesets of pre-existing items changed by Lucid */
    columnsChanged, 
    /** List of item primary keys deleted by Lucid */
    columnsDeleted, 
    /** */
    columnOrdering, 
    /** Changes to the primary key */
    primaryKey, 
    /** The syncSourceId of the changed data source */
    syncSourceId, 
    /** The syncCollectionId of the changed collection */
    syncCollectionId) {
        super(id, syncSourceId, syncCollectionId);
        this.columnsAdded = columnsAdded;
        this.columnsChanged = columnsChanged;
        this.columnsDeleted = columnsDeleted;
        this.columnOrdering = columnOrdering;
        this.primaryKey = primaryKey;
    }
    toJSON() {
        return {
            'Id': this.id,
            'ColumnsAdded': this.columnsAdded.map((column) => column.toJSON()),
            'ColumnsChanged': objMap(this.columnsChanged, (column) => column.toJSON()),
            'ColumnsDeleted': this.columnsDeleted,
            'ColumnOrdering': this.columnOrdering,
            'SyncSourceId': this.syncSourceId,
            'SyncCollectionId': this.syncCollectionId,
        };
    }
    clone() {
        return new SchemaPatch(this.id, this.columnsAdded.map((columnAdded) => columnAdded.clone()), objMap(this.columnsChanged, (columnChange) => columnChange.clone()), [...this.columnsDeleted], this.columnOrdering && [
            ...this.columnOrdering.map(([base, target]) => [base, target]),
        ], this.primaryKey && [...this.primaryKey], this.syncSourceId, this.syncCollectionId);
    }
}
exports.SchemaPatch = SchemaPatch;
function _schemaPatchParser(id, patch) {
    var _a, _b;
    return new SchemaPatch(id, patch['columnsAdded'].map(ThirdPartyColumn.deserialize), objMap(patch['columnsChanged'], ThirdPartyColumnPatch.deserialize), patch['columnsDeleted'], (_a = patch['columnOrdering']) !== null && _a !== void 0 ? _a : undefined, (_b = patch['primaryKey']) !== null && _b !== void 0 ? _b : undefined, patch['syncSourceId'], patch['syncCollectionId']);
}
const schemaPatchParser = (id, patch) => {
    if ((0, serializedpatchtypes_1.patchSchemaValidator)(patch)) {
        return _schemaPatchParser(id, patch);
    }
    return undefined;
};
exports.schemaPatchParser = schemaPatchParser;
